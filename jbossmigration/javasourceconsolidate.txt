You're thinking like a migration strategist, Laxmi‚Äîthis is exactly the kind of modular, dependency-aware approach that makes JDK and Jakarta upgrades safe and scalable. Here's a complete Python workflow broken into **three stages**:

---

## üß© Stage 1: Merge All Java Components into a Unified Source Folder

```python
import os
import shutil

def merge_java_sources(source_dirs, target_dir):
    os.makedirs(target_dir, exist_ok=True)
    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                if file.endswith(".java"):
                    rel_path = os.path.relpath(root, src)
                    dest_path = os.path.join(target_dir, rel_path)
                    os.makedirs(dest_path, exist_ok=True)
                    shutil.copy2(os.path.join(root, file), os.path.join(dest_path, file))
    print(f"‚úÖ Merged sources into: {target_dir}")
```

---

## üì¶ Stage 2: Extract Imports Class-Wise with File Paths

```python
def extract_imports(source_dir):
    import_map = {}
    for root, _, files in os.walk(source_dir):
        for file in files:
            if file.endswith(".java"):
                path = os.path.join(root, file)
                with open(path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                imports = [line.strip() for line in lines if line.strip().startswith("import ")]
                import_map[path] = imports
    return import_map
```

---

## üßπ Stage 3: Filter System & 3rd-Party Classes and Move Them

```python
def classify_and_extract(import_map, system_prefixes, third_party_prefixes, output_dir):
    os.makedirs(output_dir, exist_ok=True)
    selected_files = []

    for file_path, imports in import_map.items():
        if any(imp.startswith(f"import {prefix}") for imp in imports for prefix in system_prefixes + third_party_prefixes):
            selected_files.append(file_path)

    for src_path in selected_files:
        rel_path = os.path.relpath(src_path, start=os.path.commonpath(import_map.keys()))
        dest_path = os.path.join(output_dir, rel_path)
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        shutil.copy2(src_path, dest_path)

    print(f"‚úÖ Extracted {len(selected_files)} system/3rd-party dependent classes to: {output_dir}")
```

---

## üß† Example Usage

```python
source_dirs = ["/projects/module1/src", "/projects/module2/src"]
merged_dir = "/projects/merged-src"
output_dir = "/projects/system-lib-src"

system_prefixes = ["java.", "javax.", "jakarta."]
third_party_prefixes = ["org.apache.", "com.google.", "org.slf4j.", "org.torque.", "org.apache.fulcrum"]

merge_java_sources(source_dirs, merged_dir)
import_map = extract_imports(merged_dir)
classify_and_extract(import_map, system_prefixes, third_party_prefixes, output_dir)
```

---

## üß† Bonus Tips for You

- You can extend this to detect deprecated APIs (`sun.misc`, `Thread.stop`, etc.).
- Add a dry-run mode to preview which files will be moved.
- Integrate with Maven to compile only the extracted module against upgraded JDK/Jakarta libraries.

Would you like a version that also generates a CSV report of each file‚Äôs import classification for audit and review?



Perfect, Laxmi. Here's the enhanced version of your Python workflow that not only merges and classifies Java source files, but also generates a **CSV report** listing each file's path and its import statements‚Äîmaking it easy to audit, filter, and track system vs. application dependencies.

---

## üß© Full Workflow Overview

### ‚úÖ Stage 1: Merge All Java Files into a Unified Source Folder  
### ‚úÖ Stage 2: Extract Imports Class-Wise  
### ‚úÖ Stage 3: Classify System/3rd-Party Dependencies  
### ‚úÖ Stage 4: Generate CSV Report

---

## üêç Complete Python Script

```python
import os
import shutil
import csv

def merge_java_sources(source_dirs, target_dir):
    os.makedirs(target_dir, exist_ok=True)
    for src in source_dirs:
        for root, _, files in os.walk(src):
            for file in files:
                if file.endswith(".java"):
                    rel_path = os.path.relpath(root, src)
                    dest_path = os.path.join(target_dir, rel_path)
                    os.makedirs(dest_path, exist_ok=True)
                    shutil.copy2(os.path.join(root, file), os.path.join(dest_path, file))
    print(f"‚úÖ Merged sources into: {target_dir}")

def extract_imports(source_dir):
    import_map = {}
    for root, _, files in os.walk(source_dir):
        for file in files:
            if file.endswith(".java"):
                path = os.path.join(root, file)
                with open(path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                imports = [line.strip() for line in lines if line.strip().startswith("import ")]
                import_map[path] = imports
    return import_map

def classify_and_extract(import_map, system_prefixes, third_party_prefixes, output_dir, csv_path):
    os.makedirs(output_dir, exist_ok=True)
    selected_files = []

    with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["File Path", "Import Count", "System/3rd-Party", "Imports"])

        for file_path, imports in import_map.items():
            is_system_or_third_party = any(
                imp.startswith(f"import {prefix}") for imp in imports for prefix in system_prefixes + third_party_prefixes
            )
            tag = "System/3rd-Party" if is_system_or_third_party else "App-Specific"
            writer.writerow([file_path, len(imports), tag, "; ".join(imports)])

            if is_system_or_third_party:
                selected_files.append(file_path)

    for src_path in selected_files:
        rel_path = os.path.relpath(src_path, start=os.path.commonpath(import_map.keys()))
        dest_path = os.path.join(output_dir, rel_path)
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        shutil.copy2(src_path, dest_path)

    print(f"üìÑ CSV report generated: {csv_path}")
    print(f"‚úÖ Extracted {len(selected_files)} system/3rd-party dependent classes to: {output_dir}")
```

---

## üß† Example Usage

```python
source_dirs = ["/projects/module1/src", "/projects/module2/src"]
merged_dir = "/projects/merged-src"
output_dir = "/projects/system-lib-src"
csv_report = "/projects/import-report.csv"

system_prefixes = ["java.", "javax.", "jakarta."]
third_party_prefixes = ["org.apache.", "com.google.", "org.slf4j.", "org.torque.", "org.apache.fulcrum"]

merge_java_sources(source_dirs, merged_dir)
import_map = extract_imports(merged_dir)
classify_and_extract(import_map, system_prefixes, third_party_prefixes, output_dir, csv_report)
```

---

## üìä Sample CSV Output

| File Path                          | Import Count | System/3rd-Party | Imports                                                                 |
|-----------------------------------|--------------|------------------|-------------------------------------------------------------------------|
| `/projects/merged-src/BaseDAO.java` | 5            | System/3rd-Party | import java.sql.Connection; import org.apache.torque.util.Criteria; ... |
| `/projects/merged-src/UserService.java` | 3            | App-Specific      | import com.wipro.banking.model.User; import com.wipro.banking.dao.*;   |

---

Would you like to add a column that flags deprecated JDK APIs or shows which Jakarta imports need refactoring? I can also help you generate a migration checklist from this CSV.
